#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen 0.65.1 */

#[doc = " <summary>\n The operation completed without errors.\n </summary>"]
pub const charls_jpegls_errc_success: charls_jpegls_errc = 0;
#[doc = " <summary>\n This error is returned when one of the arguments is invalid and no specific reason is available.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument: charls_jpegls_errc = 1;
#[doc = " <summary>\n This error is returned when the JPEG stream contains a parameter value that is not supported by this implementation.\n </summary>"]
pub const charls_jpegls_errc_parameter_value_not_supported: charls_jpegls_errc = 2;
#[doc = " <summary>\n The destination buffer is too small to hold all the output.\n </summary>"]
pub const charls_jpegls_errc_destination_buffer_too_small: charls_jpegls_errc = 3;
#[doc = " <summary>\n The source buffer is too small, more input data was expected.\n </summary>"]
pub const charls_jpegls_errc_source_buffer_too_small: charls_jpegls_errc = 4;
#[doc = " <summary>\n This error is returned when the encoded bit stream contains a general structural problem.\n </summary>"]
pub const charls_jpegls_errc_invalid_encoded_data: charls_jpegls_errc = 5;
#[doc = " <summary>\n Too much compressed data.The decoding process is ready but the input buffer still contains encoded data.\n </summary>"]
pub const charls_jpegls_errc_too_much_encoded_data: charls_jpegls_errc = 6;
#[doc = " <summary>\n This error is returned when a method call is invalid for the current state.\n </summary>"]
pub const charls_jpegls_errc_invalid_operation: charls_jpegls_errc = 7;
#[doc = " <summary>\n The bit depth for transformation is not supported.\n </summary>"]
pub const charls_jpegls_errc_bit_depth_for_transform_not_supported: charls_jpegls_errc = 8;
#[doc = " <summary>\n The color transform is not supported.\n </summary>"]
pub const charls_jpegls_errc_color_transform_not_supported: charls_jpegls_errc = 9;
#[doc = " <summary>\n This error is returned when an encoded frame is found that is not encoded with the JPEG-LS algorithm.\n </summary>"]
pub const charls_jpegls_errc_encoding_not_supported: charls_jpegls_errc = 10;
#[doc = " <summary>\n This error is returned when an unknown JPEG marker code is found in the encoded bit stream.\n </summary>"]
pub const charls_jpegls_errc_unknown_jpeg_marker_found: charls_jpegls_errc = 11;
#[doc = " <summary>\n This error is returned when the algorithm expect a 0xFF code (indicates start of a JPEG marker) but none was found.\n </summary>"]
pub const charls_jpegls_errc_jpeg_marker_start_byte_not_found: charls_jpegls_errc = 12;
#[doc = " <summary>\n This error is returned when the implementation could not allocate memory for its internal buffers.\n </summary>"]
pub const charls_jpegls_errc_not_enough_memory: charls_jpegls_errc = 13;
#[doc = " <summary>\n This error is returned when the implementation encountered a failure it did not expect. No guarantees can be given\n for the state after this error.\n </summary>"]
pub const charls_jpegls_errc_unexpected_failure: charls_jpegls_errc = 14;
#[doc = " <summary>\n This error is returned when the first JPEG marker is not the SOI marker.\n </summary>"]
pub const charls_jpegls_errc_start_of_image_marker_not_found: charls_jpegls_errc = 15;
#[doc = " <summary>\n This error is returned when a JPEG marker is found that is not valid for the current state.\n </summary>"]
pub const charls_jpegls_errc_unexpected_marker_found: charls_jpegls_errc = 16;
#[doc = " <summary>\n This error is returned when the segment size of a marker segment is invalid.\n </summary>"]
pub const charls_jpegls_errc_invalid_marker_segment_size: charls_jpegls_errc = 17;
#[doc = " <summary>\n This error is returned when the stream contains more then one SOI marker.\n </summary>"]
pub const charls_jpegls_errc_duplicate_start_of_image_marker: charls_jpegls_errc = 18;
#[doc = " <summary>\n This error is returned when the stream contains more then one SOF marker.\n </summary>"]
pub const charls_jpegls_errc_duplicate_start_of_frame_marker: charls_jpegls_errc = 19;
#[doc = " <summary>\n This error is returned when the stream contains duplicate component identifiers in the SOF segment.\n </summary>"]
pub const charls_jpegls_errc_duplicate_component_id_in_sof_segment: charls_jpegls_errc = 20;
#[doc = " <summary>\n This error is returned when the stream contains an unexpected EOI marker.\n </summary>"]
pub const charls_jpegls_errc_unexpected_end_of_image_marker: charls_jpegls_errc = 21;
#[doc = " <summary>\n This error is returned when the stream contains an invalid type parameter in the JPEG-LS segment.\n </summary>"]
pub const charls_jpegls_errc_invalid_jpegls_preset_parameter_type: charls_jpegls_errc = 22;
#[doc = " <summary>\n This error is returned when the stream contains an unsupported type parameter in the JPEG-LS segment.\n </summary>"]
pub const charls_jpegls_errc_jpegls_preset_extended_parameter_type_not_supported:
charls_jpegls_errc = 23;
#[doc = " <summary>\n This error is returned when the stream contains a SPIFF header but not an SPIFF end-of-directory entry.\n </summary>"]
pub const charls_jpegls_errc_missing_end_of_spiff_directory: charls_jpegls_errc = 24;
#[doc = " <summary>\n This error is returned when a restart marker is found outside the encoded entropy data.\n </summary>"]
pub const charls_jpegls_errc_unexpected_restart_marker: charls_jpegls_errc = 25;
#[doc = " <summary>\n This error is returned when an expected restart marker is not found. It may indicate data corruption in the JPEG-LS\n byte stream.\n </summary>"]
pub const charls_jpegls_errc_restart_marker_not_found: charls_jpegls_errc = 26;
#[doc = " <summary>\n This error is returned when a callback function returns a non zero value.\n </summary>"]
pub const charls_jpegls_errc_callback_failed: charls_jpegls_errc = 27;
#[doc = " <summary>\n This error is returned when the End of Image (EOI) marker could not be found.\n </summary>"]
pub const charls_jpegls_errc_end_of_image_marker_not_found: charls_jpegls_errc = 28;
#[doc = " <summary>\n This error is returned when the SPIFF header is invalid.\n </summary>"]
pub const charls_jpegls_errc_invalid_spiff_header: charls_jpegls_errc = 29;
#[doc = " <summary>\n The argument for the width parameter is outside the range [1, 65535].\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_width: charls_jpegls_errc = 100;
#[doc = " <summary>\n The argument for the height parameter is outside the range [1, 65535].\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_height: charls_jpegls_errc = 101;
#[doc = " <summary>\n The argument for the component count parameter is outside the range [1, 255].\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_component_count: charls_jpegls_errc = 102;
#[doc = " <summary>\n The argument for the bit per sample parameter is outside the range [2, 16].\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_bits_per_sample: charls_jpegls_errc = 103;
#[doc = " <summary>\n The argument for the interleave mode is not (None, Sample, Line) or invalid in combination with component count.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_interleave_mode: charls_jpegls_errc = 104;
#[doc = " <summary>\n The argument for the near lossless parameter is outside the range [0, 255].\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_near_lossless: charls_jpegls_errc = 105;
#[doc = " <summary>\n The argument for the JPEG-LS preset coding parameters is not valid, see ISO/IEC 14495-1,\n C.2.4.1.1, Table C.1 for the ranges of valid values.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_jpegls_pc_parameters: charls_jpegls_errc = 106;
#[doc = " <summary>\n The argument for the size parameter is outside the valid range.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_size: charls_jpegls_errc = 110;
#[doc = " <summary>\n The argument for the color component is not (None, Hp1, Hp2, Hp3) or invalid in combination with component count.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_color_transformation: charls_jpegls_errc = 111;
#[doc = " <summary>\n The stride argument does not match with the frame info and buffer size.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_stride: charls_jpegls_errc = 112;
#[doc = " <summary>\n The encoding options argument has an invalid value.\n </summary>"]
pub const charls_jpegls_errc_invalid_argument_encoding_options: charls_jpegls_errc = 113;
#[doc = " <summary>\n This error is returned when the stream contains a width parameter defined more then once or in an incompatible way.\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_width: charls_jpegls_errc = 200;
#[doc = " <summary>\n This error is returned when the stream contains a height parameter defined more then once in an incompatible way.\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_height: charls_jpegls_errc = 201;
#[doc = " <summary>\n This error is returned when the stream contains a component count parameter outside the range [1,255] for SOF or\n [1,4] for SOS.\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_component_count: charls_jpegls_errc = 202;
#[doc = " <summary>\n This error is returned when the stream contains a bits per sample (sample precision) parameter outside the range\n [2,16]\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_bits_per_sample: charls_jpegls_errc = 203;
#[doc = " <summary>\n This error is returned when the stream contains an interleave mode (ILV) parameter outside the range [0, 2]\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_interleave_mode: charls_jpegls_errc = 204;
#[doc = " <summary>\n This error is returned when the stream contains a near-lossless (NEAR) parameter outside the range [0, min(255,\n MAXVAL/2)]\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_near_lossless: charls_jpegls_errc = 205;
#[doc = " <summary>\n This error is returned when the stream contains an invalid JPEG-LS preset parameters segment.\n </summary>"]
pub const charls_jpegls_errc_invalid_parameter_jpegls_preset_parameters: charls_jpegls_errc = 206;
#[doc = " <summary>\n Defines the result values that are returned by the CharLS API functions.\n </summary>"]
pub type charls_jpegls_errc = ::std::os::raw::c_int;
#[doc = " <summary>\n The data is encoded and stored as component for component: RRRGGGBBB.\n </summary>"]
pub const charls_interleave_mode_none: charls_interleave_mode = 0;
#[doc = " <summary>\n The interleave mode is by line. A full line of each component is encoded before moving to the next line.\n </summary>"]
pub const charls_interleave_mode_line: charls_interleave_mode = 1;
#[doc = " <summary>\n The data is encoded and stored by sample. For RGB color images this is the format like RGBRGBRGB.\n </summary>"]
pub const charls_interleave_mode_sample: charls_interleave_mode = 2;
#[doc = " <summary>\n Defines the interleave modes for multi-component (color) pixel data.\n </summary>"]
pub type charls_interleave_mode = ::std::os::raw::c_int;
#[doc = " <summary>\n No special encoding option is defined.\n </summary>"]
pub const charls_encoding_options_private_encoding_options_none:
charls_encoding_options_private_encoding_options = 0;
#[doc = " <summary>\n Ensures that the generated encoded data has an even size by adding\n an extra 0xFF byte to the End Of Image (EOI) marker.\n DICOM requires that data is always even. This can be done by adding a zero padding byte\n after the encoded data or with this option.\n This option is not default enabled.\n </summary>"]
pub const charls_encoding_options_private_encoding_options_even_destination_size:
charls_encoding_options_private_encoding_options = 1;
#[doc = " <summary>\n Add a comment (COM) segment with the content: \"charls [version-number]\" to the encoded data.\n Storing the used encoder version can be helpful for long term archival of images.\n This option is not default enabled.\n </summary>"]
pub const charls_encoding_options_private_encoding_options_include_version_number:
charls_encoding_options_private_encoding_options = 2;
#[doc = " <summary>\n Writes explicitly the default JPEG-LS preset coding parameters when the\n bits per sample is larger then 12 bits.\n The Java Advanced Imaging (JAI) JPEG-LS codec has a defect that causes it to use invalid\n preset coding parameters for these types of images.\n Most users of this codec are aware of this problem and have implemented a work-around.\n This option is default enabled. Will not be default enabled in the next major version upgrade.\n </summary>"]
pub const charls_encoding_options_private_encoding_options_include_pc_parameters_jai:
charls_encoding_options_private_encoding_options = 4;
#[doc = " <summary>\n Defines options that can be enabled during the encoding process.\n These options can be combined.\n </summary>"]
pub type charls_encoding_options_private_encoding_options = ::std::os::raw::c_uint;
#[doc = " <summary>\n Defines options that can be enabled during the encoding process.\n These options can be combined.\n </summary>"]
pub use self::charls_encoding_options_private_encoding_options as charls_encoding_options;
#[doc = " <summary>\n No profile identified.\n This is the only valid option for JPEG-LS encoded images.\n </summary>"]
pub const charls_spiff_profile_id_none: charls_spiff_profile_id = 0;
#[doc = " <summary>\n Continuous-tone base profile (JPEG)\n </summary>"]
pub const charls_spiff_profile_id_continuous_tone_base: charls_spiff_profile_id = 1;
#[doc = " <summary>\n Continuous-tone progressive profile\n </summary>"]
pub const charls_spiff_profile_id_continuous_tone_progressive: charls_spiff_profile_id = 2;
#[doc = " <summary>\n Bi-level facsimile profile (MH, MR, MMR, JBIG)\n </summary>"]
pub const charls_spiff_profile_id_bi_level_facsimile: charls_spiff_profile_id = 3;
#[doc = " <summary>\n Continuous-tone facsimile profile (JPEG)\n </summary>"]
pub const charls_spiff_profile_id_continuous_tone_facsimile: charls_spiff_profile_id = 4;
#[doc = " <summary>\n Defines the Application profile identifier options that can be used in a SPIFF header v2, as defined in ISO/IEC 10918-3,\n F.1.2\n </summary>"]
pub type charls_spiff_profile_id = i32;
#[doc = " <summary>\n Bi-level image. Each image sample is one bit: 0 = white and 1 = black.\n This option is not valid for JPEG-LS encoded images.\n </summary>"]
pub const charls_spiff_color_space_bi_level_black: charls_spiff_color_space = 0;
#[doc = " <summary>\n The color space is based on recommendation ITU-R BT.709.\n </summary>"]
pub const charls_spiff_color_space_ycbcr_itu_bt_709_video: charls_spiff_color_space = 1;
#[doc = " <summary>\n Color space interpretation of the coded sample is none of the other options.\n </summary>"]
pub const charls_spiff_color_space_none: charls_spiff_color_space = 2;
#[doc = " <summary>\n The color space is based on recommendation ITU-R BT.601-1. (RGB).\n </summary>"]
pub const charls_spiff_color_space_ycbcr_itu_bt_601_1_rgb: charls_spiff_color_space = 3;
#[doc = " <summary>\n The color space is based on recommendation ITU-R BT.601-1. (video).\n </summary>"]
pub const charls_spiff_color_space_ycbcr_itu_bt_601_1_video: charls_spiff_color_space = 4;
#[doc = " <summary>\n Grayscale – This is a single component sample with interpretation as grayscale value, 0 is minimum, 2bps -1 is\n maximum.\n </summary>"]
pub const charls_spiff_color_space_grayscale: charls_spiff_color_space = 8;
#[doc = " <summary>\n This is the color encoding method used in the Photo CD™ system.\n </summary>"]
pub const charls_spiff_color_space_photo_ycc: charls_spiff_color_space = 9;
#[doc = " <summary>\n The encoded data consists of samples of (uncalibrated) R, G and B.\n </summary>"]
pub const charls_spiff_color_space_rgb: charls_spiff_color_space = 10;
#[doc = " <summary>\n The encoded data consists of samples of Cyan, Magenta and Yellow samples.\n </summary>"]
pub const charls_spiff_color_space_cmy: charls_spiff_color_space = 11;
#[doc = " <summary>\n The encoded data consists of samples of Cyan, Magenta, Yellow and Black samples.\n </summary>"]
pub const charls_spiff_color_space_cmyk: charls_spiff_color_space = 12;
#[doc = " <summary>\n Transformed CMYK type data (same as Adobe PostScript)\n </summary>"]
pub const charls_spiff_color_space_ycck: charls_spiff_color_space = 13;
#[doc = " <summary>\n The CIE 1976 (L* a* b*) color space.\n </summary>"]
pub const charls_spiff_color_space_cie_lab: charls_spiff_color_space = 14;
#[doc = " <summary>\n Bi-level image. Each image sample is one bit: 1 = white and 0 = black.\n This option is not valid for JPEG-LS encoded images.\n </summary>"]
pub const charls_spiff_color_space_bi_level_white: charls_spiff_color_space = 15;
#[doc = " <summary>\n Defines the color space options that can be used in a SPIFF header v2, as defined in ISO/IEC 10918-3, F.2.1.1\n </summary>"]
pub type charls_spiff_color_space = i32;
#[doc = " <summary>\n Picture data is stored in component interleaved format, encoded at BPS per sample.\n </summary>"]
pub const charls_spiff_compression_type_uncompressed: charls_spiff_compression_type = 0;
#[doc = " <summary>\n Recommendation T.4, the basic algorithm commonly known as MH (Modified Huffman), only allowed for bi-level images.\n </summary>"]
pub const charls_spiff_compression_type_modified_huffman: charls_spiff_compression_type = 1;
#[doc = " <summary>\n Recommendation T.4, commonly known as MR (Modified READ), only allowed for bi-level images.\n </summary>"]
pub const charls_spiff_compression_type_modified_read: charls_spiff_compression_type = 2;
#[doc = " <summary>\n Recommendation T .6, commonly known as MMR (Modified Modified READ), only allowed for bi-level images.\n </summary>"]
pub const charls_spiff_compression_type_modified_modified_read: charls_spiff_compression_type = 3;
#[doc = " <summary>\n ISO/IEC 11544, commonly known as JBIG, only allowed for bi-level images.\n </summary>"]
pub const charls_spiff_compression_type_jbig: charls_spiff_compression_type = 4;
#[doc = " <summary>\n ISO/IEC 10918-1 or ISO/IEC 10918-3, commonly known as JPEG.\n </summary>"]
pub const charls_spiff_compression_type_jpeg: charls_spiff_compression_type = 5;
#[doc = " <summary>\n ISO/IEC 14495-1 or ISO/IEC 14495-2, commonly known as JPEG-LS. (extension defined in ISO/IEC 14495-1).\n This is the only valid option for JPEG-LS encoded images.\n </summary>"]
pub const charls_spiff_compression_type_jpeg_ls: charls_spiff_compression_type = 6;
#[doc = " <summary>\n Defines the compression options that can be used in a SPIFF header v2, as defined in ISO/IEC 10918-3, F.2.1\n </summary>"]
pub type charls_spiff_compression_type = i32;
#[doc = " <summary>\n VRES and HRES are to be interpreted as aspect ratio.\n </summary>\n <remark>\n If vertical or horizontal resolutions are not known, use this option and set VRES and HRES\n both to 1 to indicate that pixels in the image should be assumed to be square.\n </remark>"]
pub const charls_spiff_resolution_units_aspect_ratio: charls_spiff_resolution_units = 0;
#[doc = " <summary>\n Units of dots/samples per inch\n </summary>"]
pub const charls_spiff_resolution_units_dots_per_inch: charls_spiff_resolution_units = 1;
#[doc = " <summary>\n Units of dots/samples per centimeter.\n </summary>"]
pub const charls_spiff_resolution_units_dots_per_centimeter: charls_spiff_resolution_units = 2;
#[doc = " <summary>\n Defines the resolution units for the VRES and HRES parameters, as defined in ISO/IEC 10918-3, F.2.1\n </summary>"]
pub type charls_spiff_resolution_units = i32;
#[doc = " <summary>\n Defines the information that can be stored in a SPIFF header as defined in ISO/IEC 10918-3, Annex F\n </summary>\n <remark>\n The type I.8 is an unsigned 8 bit integer, the type I.32 is an 32 bit unsigned integer in the file header itself.\n The type is indicated by the symbol “F.” are 4-byte parameters in “fixed point” notation.\n The 16 most significant bits are essentially the same as a parameter of type I.16 and indicate the integer\n part of this number.\n The 16 least significant bits are essentially the same as an I.16 parameter and contain an unsigned integer that,\n when divided by 65536, represents the fractional part of the fixed point number.\n </remark>"]
#[repr(C)]
pub struct charls_spiff_header {
    pub profile_id: charls_spiff_profile_id,
    pub component_count: i32,
    pub height: u32,
    pub width: u32,
    pub color_space: charls_spiff_color_space,
    pub bits_per_sample: i32,
    pub compression_type: charls_spiff_compression_type,
    pub resolution_units: charls_spiff_resolution_units,
    pub vertical_resolution: u32,
    pub horizontal_resolution: u32,
}
#[test]
fn bindgen_test_layout_charls_spiff_header() {
    const UNINIT: ::std::mem::MaybeUninit<charls_spiff_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<charls_spiff_header>(),
        40usize,
        concat!("Size of: ", stringify!(charls_spiff_header))
    );
    assert_eq!(
        ::std::mem::align_of::<charls_spiff_header>(),
        4usize,
        concat!("Alignment of ", stringify!(charls_spiff_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_id) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(profile_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_count) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(component_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_space) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression_type) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(compression_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution_units) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(resolution_units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertical_resolution) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(vertical_resolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontal_resolution) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_spiff_header),
        "::",
        stringify!(horizontal_resolution)
        )
    );
}
#[doc = " <summary>\n Defines the information that can be stored in a JPEG-LS Frame marker segment that applies to all scans.\n </summary>\n <remark>\n The JPEG-LS also allow to store sub-sampling information in a JPEG-LS Frame marker segment.\n CharLS does not support JPEG-LS images that contain sub-sampled scans.\n </remark>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charls_frame_info {
    #[doc = " <summary>\n Width of the image, range [1, 65535].\n </summary>"]
    pub width: u32,
    #[doc = " <summary>\n Height of the image, range [1, 65535].\n </summary>"]
    pub height: u32,
    #[doc = " <summary>\n Number of bits per sample, range [2, 16]\n </summary>"]
    pub bits_per_sample: i32,
    #[doc = " <summary>\n Number of components contained in the frame, range [1, 255]\n </summary>"]
    pub component_count: i32,
}
#[test]
fn bindgen_test_layout_charls_frame_info() {
    const UNINIT: ::std::mem::MaybeUninit<charls_frame_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<charls_frame_info>(),
        16usize,
        concat!("Size of: ", stringify!(charls_frame_info))
    );
    assert_eq!(
        ::std::mem::align_of::<charls_frame_info>(),
        4usize,
        concat!("Alignment of ", stringify!(charls_frame_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_frame_info),
        "::",
        stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_frame_info),
        "::",
        stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_frame_info),
        "::",
        stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_count) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_frame_info),
        "::",
        stringify!(component_count)
        )
    );
}
#[doc = " <summary>\n Defines the JPEG-LS preset coding parameters as defined in ISO/IEC 14495-1, C.2.4.1.1.\n JPEG-LS defines a default set of parameters, but custom parameters can be used.\n When used these parameters are written into the encoded bit stream as they are needed for the decoding process.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charls_jpegls_pc_parameters {
    #[doc = " <summary>\n Maximum possible value for any image sample in a scan.\n This must be greater than or equal to the actual maximum value for the components in a scan.\n </summary>"]
    pub maximum_sample_value: i32,
    #[doc = " <summary>\n First quantization threshold value for the local gradients.\n </summary>"]
    pub threshold1: i32,
    #[doc = " <summary>\n Second quantization threshold value for the local gradients.\n </summary>"]
    pub threshold2: i32,
    #[doc = " <summary>\n Third quantization threshold value for the local gradients.\n </summary>"]
    pub threshold3: i32,
    #[doc = " <summary>\n Value at which the counters A, B, and N are halved.\n </summary>"]
    pub reset_value: i32,
}
#[test]
fn bindgen_test_layout_charls_jpegls_pc_parameters() {
    const UNINIT: ::std::mem::MaybeUninit<charls_jpegls_pc_parameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<charls_jpegls_pc_parameters>(),
        20usize,
        concat!("Size of: ", stringify!(charls_jpegls_pc_parameters))
    );
    assert_eq!(
        ::std::mem::align_of::<charls_jpegls_pc_parameters>(),
        4usize,
        concat!("Alignment of ", stringify!(charls_jpegls_pc_parameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum_sample_value) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_jpegls_pc_parameters),
        "::",
        stringify!(maximum_sample_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold1) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_jpegls_pc_parameters),
        "::",
        stringify!(threshold1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold2) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_jpegls_pc_parameters),
        "::",
        stringify!(threshold2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold3) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_jpegls_pc_parameters),
        "::",
        stringify!(threshold3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_value) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(charls_jpegls_pc_parameters),
        "::",
        stringify!(reset_value)
        )
    );
}
extern "C" {
    pub fn charls_get_error_message(
        error_value: charls_jpegls_errc,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charls_jpegls_decoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " <summary>\n Creates a JPEG-LS decoder instance, when finished with the instance destroy it with the function\n charls_jpegls_decoder_destroy.\n </summary>\n <returns>A reference to a new created decoder instance, or a null pointer when the creation fails.</returns>"]
    pub fn charls_jpegls_decoder_create() -> *mut charls_jpegls_decoder;
}
extern "C" {
    #[doc = " <summary>\n Destroys a JPEG-LS decoder instance created with charls_jpegls_decoder_create and releases all internal resources\n attached to it.\n </summary>\n <param name=\"decoder\">Instance to destroy. If a null pointer is passed as argument, no action occurs.</param>"]
    pub fn charls_jpegls_decoder_destroy(decoder: *const charls_jpegls_decoder);
}
extern "C" {
    #[doc = " <summary>\n Set the reference to a source buffer that contains the encoded JPEG-LS byte stream data.\n This buffer needs to remain valid until the buffer is fully decoded.\n </summary>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <param name=\"source_buffer\">Reference to the start of the source buffer.</param>\n <param name=\"source_size_bytes\">Size of the source buffer in bytes.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_set_source_buffer(
        decoder: *mut charls_jpegls_decoder,
        source_buffer: *const ::std::os::raw::c_void,
        source_size_bytes: usize,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Tries to read the SPIFF header from the source buffer.\n If a SPIFF header exists its content will be put into the spiff_header parameter and header_found will be set to 1.\n Call charls_jpegls_decoder_read_header to read the normal JPEG header afterwards.\n </summary>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <param name=\"spiff_header\">Output argument, will hold the SPIFF header when one could be found.</param>\n <param name=\"header_found\">Output argument, will hold 1 if a SPIFF header could be found, otherwise 0.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_read_spiff_header(
        decoder: *mut charls_jpegls_decoder,
        spiff_header: *mut charls_spiff_header,
        header_found: *mut i32,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Reads the JPEG-LS header from the JPEG byte stream. After this function is called frame info can be retrieved.\n </summary>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_read_header(
        decoder: *mut charls_jpegls_decoder,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Returns information about the frame stored in the JPEG-LS byte stream.\n </summary>\n <remarks>\n Function should be called after calling the function charls_jpegls_decoder_read_header.\n </remarks>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <param name=\"frame_info\">Output argument, will hold the frame info when the function returns.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_get_frame_info(
        decoder: *const charls_jpegls_decoder,
        frame_info: *mut charls_frame_info,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Returns the size required for the destination buffer in bytes to hold the decoded pixel data.\n </summary>\n <remarks>\n Function should be called after calling the function charls_jpegls_decoder_read_header.\n </remarks>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <param name=\"stride\">Number of bytes to the next line in the buffer, when zero, decoder will compute it.</param>\n <param name=\"destination_size_bytes\">Output argument, will hold the required size when the function returns.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_get_destination_size(
        decoder: *const charls_jpegls_decoder,
        stride: u32,
        destination_size_bytes: *mut usize,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Will decode the JPEG-LS byte stream from the source buffer into the destination buffer.\n </summary>\n <remarks>\n Function should be called after calling the function charls_jpegls_decoder_read_header.\n </remarks>\n <param name=\"decoder\">Reference to the decoder instance.</param>\n <param name=\"destination_buffer\">Byte array that holds the encoded bytes when the function returns.</param>\n <param name=\"destination_size_bytes\">\n Length of the array in bytes. If the array is too small the function will return an error.\n </param>\n <param name=\"stride\">\n Number of bytes to the next line in the buffer, when zero, decoder will compute it.\n </param> <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_decoder_decode_to_buffer(
        decoder: *mut charls_jpegls_decoder,
        destination_buffer: *mut ::std::os::raw::c_void,
        destination_size_bytes: usize,
        stride: u32,
    ) -> charls_jpegls_errc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charls_jpegls_encoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " <summary>\n Creates a JPEG-LS encoder instance, when finished with the instance destroy it with the function\n charls_jpegls_encoder_destroy.\n </summary>\n <returns>A reference to a new created encoder instance, or a null pointer when the creation fails.</returns>"]
    pub fn charls_jpegls_encoder_create() -> *mut charls_jpegls_encoder;
}
extern "C" {
    #[doc = " <summary>\n Destroys a JPEG-LS encoder instance created with charls_jpegls_encoder_create and releases all internal resources\n attached to it.\n </summary>\n <param name=\"encoder\">Instance to destroy. If a null pointer is passed as argument, no action occurs.</param>"]
    pub fn charls_jpegls_encoder_destroy(encoder: *const charls_jpegls_encoder);
}
extern "C" {
    #[doc = " <summary>\n Configures the frame that needs to be encoded. This information will be written to the Start of Frame segment.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"frame_info\">Information about the frame that needs to be encoded.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_frame_info(
        encoder: *mut charls_jpegls_encoder,
        frame_info: *const charls_frame_info,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Configures the NEAR parameter the encoder should use. A value of 0 means lossless, 0 is also the default.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"near_lossless\">Value of the NEAR parameter.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_near_lossless(
        encoder: *mut charls_jpegls_encoder,
        near_lossless: i32,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Configures the encoding options the encoder should use. Default is charls_encoding_options::include_pc_parameters_jai\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"encoding_options\">Options to use.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_encoding_options(
        encoder: *mut charls_jpegls_encoder,
        encoding_options: charls_encoding_options,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Configures the interleave mode the encoder should use. The default is none.\n The encoder expects the input buffer in the same format as the interleave mode.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"interleave_mode\">Value of the interleave mode.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_interleave_mode(
        encoder: *mut charls_jpegls_encoder,
        interleave_mode: charls_interleave_mode,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Configures the preset coding parameters the encoder should use.\n If not set the encoder will use the default preset coding parameters as defined by the JPEG-LS standard.\n Only when the coding parameters are different than the default parameters or when `include_pc_parameters_jai` is set,\n they will be written to the JPEG-LS stream during the encode phase.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"preset_coding_parameters\">Reference to the preset coding parameters.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_preset_coding_parameters(
        encoder: *mut charls_jpegls_encoder,
        preset_coding_parameters: *const charls_jpegls_pc_parameters,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Returns the size in bytes, that the encoder expects are needed to hold the encoded image.\n </summary>\n <remarks>\n Size for dynamic extras like SPIFF entries and other tables are not included in this size.\n </remarks>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"size_in_bytes\">Reference to the size that will be set when the functions returns.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_get_estimated_destination_size(
        encoder: *const charls_jpegls_encoder,
        size_in_bytes: *mut usize,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Set the reference to the destination buffer that will contain the encoded JPEG-LS byte stream data after encoding.\n This buffer needs to remain valid during the encoding process.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"destination_buffer\">Reference to the start of the destination buffer.</param>\n <param name=\"destination_size_bytes\">Size of the destination buffer in bytes.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_set_destination_buffer(
        encoder: *mut charls_jpegls_encoder,
        destination_buffer: *mut ::std::os::raw::c_void,
        destination_size_bytes: usize,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Encodes the passed buffer with the source image data to the destination.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"source_buffer\">Byte array that holds the image data that needs to be encoded.</param>\n <param name=\"source_size_bytes\">Length of the array in bytes.</param>\n <param name=\"stride\">\n The number of bytes from one row of pixels in memory to the next row of pixels in memory.\n Stride is sometimes called pitch. If padding bytes are present, the stride is wider than the width of the image.\n </param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_encode_from_buffer(
        encoder: *mut charls_jpegls_encoder,
        source_buffer: *const ::std::os::raw::c_void,
        source_size_bytes: usize,
        stride: u32,
    ) -> charls_jpegls_errc;
}
extern "C" {
    #[doc = " <summary>\n Returns the size in bytes, that are written to the destination.\n </summary>\n <param name=\"encoder\">Reference to the encoder instance.</param>\n <param name=\"bytes_written\">Reference to the size that will be set when the functions returns.</param>\n <returns>The result of the operation: success or a failure code.</returns>"]
    pub fn charls_jpegls_encoder_get_bytes_written(
        encoder: *const charls_jpegls_encoder,
        bytes_written: *mut usize,
    ) -> charls_jpegls_errc;
}
